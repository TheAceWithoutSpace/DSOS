{"ast":null,"code":"'use strict';\n\nvar IsCallable = require('es-abstract/2019/IsCallable');\n\nvar functionsHaveNames = require('functions-have-names')();\n\nvar callBound = require('es-abstract/helpers/callBound');\n\nvar $functionToString = callBound('Function.prototype.toString');\nvar $stringMatch = callBound('String.prototype.match');\nvar classRegex = /^class /;\n\nvar isClass = function isClassConstructor(fn) {\n  if (IsCallable(fn)) {\n    return false;\n  }\n\n  if (typeof fn !== 'function') {\n    return false;\n  }\n\n  try {\n    var match = $stringMatch($functionToString(fn), classRegex);\n    return !!match;\n  } catch (e) {}\n\n  return false;\n};\n\nvar regex = /\\s*function\\s+([^(\\s]*)\\s*/;\nvar functionProto = Function.prototype;\n\nmodule.exports = function getName() {\n  if (!isClass(this) && !IsCallable(this)) {\n    throw new TypeError('Function.prototype.name sham getter called on non-function');\n  }\n\n  if (functionsHaveNames) {\n    return this.name;\n  }\n\n  if (this === functionProto) {\n    return '';\n  }\n\n  var str = $functionToString(this);\n  var match = $stringMatch(str, regex);\n  var name = match && match[1];\n  return name;\n};","map":{"version":3,"sources":["C:/Users/ben78/Desktop/ספר פרוקייט/DSOS/Frontend/dsos/node_modules/function.prototype.name/implementation.js"],"names":["IsCallable","require","functionsHaveNames","callBound","$functionToString","$stringMatch","classRegex","isClass","isClassConstructor","fn","match","e","regex","functionProto","Function","prototype","module","exports","getName","TypeError","name","str"],"mappings":"AAAA;;AAEA,IAAIA,UAAU,GAAGC,OAAO,CAAC,6BAAD,CAAxB;;AACA,IAAIC,kBAAkB,GAAGD,OAAO,CAAC,sBAAD,CAAP,EAAzB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,+BAAD,CAAvB;;AACA,IAAIG,iBAAiB,GAAGD,SAAS,CAAC,6BAAD,CAAjC;AACA,IAAIE,YAAY,GAAGF,SAAS,CAAC,wBAAD,CAA5B;AAEA,IAAIG,UAAU,GAAG,SAAjB;;AAEA,IAAIC,OAAO,GAAG,SAASC,kBAAT,CAA4BC,EAA5B,EAAgC;AAC7C,MAAIT,UAAU,CAACS,EAAD,CAAd,EAAoB;AACnB,WAAO,KAAP;AACA;;AACD,MAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC7B,WAAO,KAAP;AACA;;AACD,MAAI;AACH,QAAIC,KAAK,GAAGL,YAAY,CAACD,iBAAiB,CAACK,EAAD,CAAlB,EAAwBH,UAAxB,CAAxB;AACA,WAAO,CAAC,CAACI,KAAT;AACA,GAHD,CAGE,OAAOC,CAAP,EAAU,CAAE;;AACd,SAAO,KAAP;AACA,CAZD;;AAcA,IAAIC,KAAK,GAAG,4BAAZ;AAEA,IAAIC,aAAa,GAAGC,QAAQ,CAACC,SAA7B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,OAAT,GAAmB;AACnC,MAAI,CAACX,OAAO,CAAC,IAAD,CAAR,IAAkB,CAACP,UAAU,CAAC,IAAD,CAAjC,EAAyC;AACxC,UAAM,IAAImB,SAAJ,CAAc,4DAAd,CAAN;AACA;;AACD,MAAIjB,kBAAJ,EAAwB;AACvB,WAAO,KAAKkB,IAAZ;AACA;;AACD,MAAI,SAASP,aAAb,EAA4B;AAC3B,WAAO,EAAP;AACA;;AACD,MAAIQ,GAAG,GAAGjB,iBAAiB,CAAC,IAAD,CAA3B;AACA,MAAIM,KAAK,GAAGL,YAAY,CAACgB,GAAD,EAAMT,KAAN,CAAxB;AACA,MAAIQ,IAAI,GAAGV,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAzB;AACA,SAAOU,IAAP;AACA,CAdD","sourcesContent":["'use strict';\r\n\r\nvar IsCallable = require('es-abstract/2019/IsCallable');\r\nvar functionsHaveNames = require('functions-have-names')();\r\nvar callBound = require('es-abstract/helpers/callBound');\r\nvar $functionToString = callBound('Function.prototype.toString');\r\nvar $stringMatch = callBound('String.prototype.match');\r\n\r\nvar classRegex = /^class /;\r\n\r\nvar isClass = function isClassConstructor(fn) {\r\n\tif (IsCallable(fn)) {\r\n\t\treturn false;\r\n\t}\r\n\tif (typeof fn !== 'function') {\r\n\t\treturn false;\r\n\t}\r\n\ttry {\r\n\t\tvar match = $stringMatch($functionToString(fn), classRegex);\r\n\t\treturn !!match;\r\n\t} catch (e) {}\r\n\treturn false;\r\n};\r\n\r\nvar regex = /\\s*function\\s+([^(\\s]*)\\s*/;\r\n\r\nvar functionProto = Function.prototype;\r\n\r\nmodule.exports = function getName() {\r\n\tif (!isClass(this) && !IsCallable(this)) {\r\n\t\tthrow new TypeError('Function.prototype.name sham getter called on non-function');\r\n\t}\r\n\tif (functionsHaveNames) {\r\n\t\treturn this.name;\r\n\t}\r\n\tif (this === functionProto) {\r\n\t\treturn '';\r\n\t}\r\n\tvar str = $functionToString(this);\r\n\tvar match = $stringMatch(str, regex);\r\n\tvar name = match && match[1];\r\n\treturn name;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}